export function removeDuplicateLetters(s: string): string {
  // 首先定义一个栈
  const stack: string[] = []
  // 遍历整个字符串
  for (let i = 0, len = s.length; i < len; i++) {
    // 在让每个字符进栈之前先判断栈中是否已经有相同字符，如果有则直接跳过
    // 因为经过下方循环处理后，栈中已经是字典序最小，此时所以如果出现重复，则直接忽略即可
    if (stack.indexOf(s[i]) !== -1) continue
    // 我们要让栈中的字符是字典序最小排列的
    // 字典序：即按照字典的顺序排列，字典序最小简单理解就是：首先看第一个字母，再看第二个字母，以此类推
    // 比如 ab < ba（第一个字母a比b小）， aa < ab（第一个字母相同，第二个字母a < b）
    // 所以我们就需要在每个字符进栈前先判断当前栈顶字符是不是比当前遍历字符大，并且后续还有和栈顶字符相同的字符
    // 满足上述两个条件我们就让栈顶字符出栈，接着我们让当前遍历字符循环判断，直到不满足上述条件为止

    // 为什么需要循环判断，我们拿"bcabc"举例，按照上面的条件，前面的"b"和"c"都是可以正常入栈的
    // 第一次判断时，栈中无值，所以stack[stack.length - 1]为undefined，判断时转换为NaN，NaN与任何值比较都为false
    // 所以不会进入while，直接将"b" push进栈
    // 第二次判断时，栈顶为"b"，当前遍历值为"c"，"b" < "c"，所以不进入while，"c"直接进栈
    // 第三次判断时， 栈顶为 "c"，当前遍历值为"a"，"a" < "c"并且"c"在后面还会出现，所以"c"出栈
    // 但是此时我们还不能让"a"直接进栈，因为"c"出栈后栈顶为"b"，"b"大于"a"并且"b"也许在后面还会出现，所以我们要继续判断
    // 直到栈顶的字符比当前遍历字符小或者后面不再出现为止
    while (
      s[i] < stack[stack.length - 1] &&
      s.indexOf(stack[stack.length - 1], i) !== -1
    ) {
      stack.pop()
    }
    // 在保证栈中的字符是字典序最小后，我们将当前遍历字符入栈
    stack.push(s[i])
  }

  // 最后连接栈中字符返回即可
  return stack.join('')
}
